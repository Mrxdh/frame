<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <ul>
        <li>
            <h2>Angular</h2>
            <p>
                AngularJS是为了克服HTML在构建应用上的不足而设计的。HTML是一门很好的为静态文本展示设计的声明式语言，但要构建WEB应用的话它就显得乏力了。所以我做了一些工作（你也可以觉得是小花招）来让浏览器做我想要的事。
                通常，我们是通过以下技术来解决静态网页技术在构建动态应用上的不足：
                类库 - 类库是一些函数的集合，它能帮助你写WEB应用。起主导作用的是你的代码，由你来决定何时使用类库。类库有：jQuery等
                框架 - 框架是一种特殊的、已经实现了的WEB应用，你只需要对它填充具体的业务逻辑。这里框架是起主导作用的，由它来根据具体的应用逻辑来调用你的代码。框架有：knockout、sproutcore等。
                AngularJS使用了不同的方法，它尝试去补足HTML本身在构建应用方面的缺陷。AngularJS通过使用我们称为标识符(directives)的结构，让浏览器能够识别新的语法。例如：
                使用双大括号{{}}语法进行数据绑定；
                使用DOM控制结构来实现迭代或者隐藏DOM片段；
                支持表单和表单的验证；
                能将逻辑代码关联到相关的DOM元素上；
                能将HTML分组成可重用的组件。
            </p>
        </li>
        <li>
            <h2>Backbone</h2>
            <p>
                Backbone.js为复杂WEB应用程序提供模型(models)、集合(collections)、视图(views)的结构。其中模型用于绑定键值数据和自定义事件；集合附有可枚举函数的丰富API； 视图可以声明事件处理函数，并通过RESRful JSON接口连接到应用程序。
            </p>
        </li>
        <li>
            <h2>Console</h2>
            <p>
                是前端下的 浏览器控制台调试语句 用来调试信息 用来调试 和 帮输出语句
                console.log   console.dir   console.debug  console.info
            </p>
        </li>
        <li>
            <h2>RequireJs</h2>
            <p>
                是前端下的 浏览器控制台调试语句 用来调试信息 用来调试 和 帮输出语句
                console.log   console.dir   console.debug  console.info
            </p>
        </li>
        <li>
            <h2>SeaJs</h2>
            <p>Sea.js 追求简单、自然的代码书写和组织方式，具有以下核心特性：

                简单友好的模块定义规范：Sea.js 遵循 CMD 规范，可以像 Node.js 一般书写模块代码。
                自然直观的代码组织方式：依赖的自动加载、配置的简洁清晰，可以让我们更多地享受编码的乐趣。
                Sea.js 还提供常用插件，非常有助于开发调试和性能优化，并具有丰富的可扩展接口。</p>
        </li>
        <li>
            <h2>SeaJs</h2>
            <p>Sea.js 追求简单、自然的代码书写和组织方式，具有以下核心特性：

                简单友好的模块定义规范：Sea.js 遵循 CMD 规范，可以像 Node.js 一般书写模块代码。
                自然直观的代码组织方式：依赖的自动加载、配置的简洁清晰，可以让我们更多地享受编码的乐趣。
                Sea.js 还提供常用插件，非常有助于开发调试和性能优化，并具有丰富的可扩展接口。</p>
        </li>
        <li>
            <h2>Express</h2>
            <p>Express 是一个简洁而灵活的 node.js Web应用框架, 提供一系列强大特性帮助你创建各种Web应用。Express 不对 node.js 已有的特性进行二次抽象，我们只是在它之上扩展了Web应用所需的功能。丰富的HTTP工具以及来自Connect框架的中间件随取随用，创建强健、友好的API变得快速又简单</p>
        </li>
        <li>
            <h2>NodeJs</h2>
            <p>Node.js 的优势是「高并发」，所以很适合用来做 IO 调度，但不太适合用来做复杂计算。 优点：1. 高并发（最重要的优点）

                2. 适合I/O密集型应用

                缺点：1. 不适合CPU密集型应用；CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起；

                解决方案：分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起；

                2. 只支持单核CPU，不能充分利用CPU

                3. 可靠性低，一旦代码某个环节崩溃，整个系统都崩溃

                原因：单进程，单线程

                解决方案：（1）Nnigx反向代理，负载均衡，开多个进程，绑定多个端口；

                （2）开多个进程监听同一个端口，使用cluster模块；</p>
        </li>
        <li>
            <h2>Grunt</h2>
            <p>对于需要反复重复的任务，例如压缩、编译、单元测试、代码检查等，自动化工具可以减轻你的劳动，简化你的工作。那么为何选择Grunt呢？可是是没有更好的选择了。</p>
        </li>
        <li>
            <h2>JSONP</h2>
            <p>JSONP即JSON with Padding。由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源。如果要进行跨域请求，我们可以通过使用html的script标记来进行跨域请求，并在响应中返回要执行的script代码，其中可以直接使用JSON传递javascript对象。这种跨域的通讯方式称为JSONP。
                很明显，JSONP是一种脚本注入(Script Injection)行为，需要特别注意其安全性。 </p>
        </li>
        <li>
            <h2>Fiddler</h2>
            <p>　　百度百科里是这样介绍它的 - “Fiddler是一个web调试代理。它能够记录所有客户端和服务器间的http请求，允许你监视，设置断点，甚至修改输入输出数据，fiddler包含了一个强大的基于事件脚本的子系统，并且能够使用.net框架语言扩展。”</p>
        </li>
        <li>
            <h2>Localstorage</h2>
            <p>HTML5 提供了两种在客户端存储数据的新方法：
                localStorage - 没有时间限制的数据存储
                sessionStorage - 针对一个 session 的数据存储
                之前，这些都是由 cookie 完成的。但是 cookie 不适合大量数据的存储，因为它们由每个对服务器的请求来传递，这使得 cookie 速度很慢而且效率也不高。
                在 HTML5 中，数据不是由每个服务器请求传递的，而是只有在请求时使用数据。它使在不影响网站性能的情况下存储大量数据成为可能。
                对于不同的网站，数据存储于不同的区域，并且一个网站只能访问其自身的数据。
                HTML5 使用 JavaScript 来存储和访问数据。</p>
        </li>
        <li>
            <h2>Opacity</h2>
            <p>设置 div 元素的不透明级别 </p>
        </li>
        <li>
            <h2>Prototype</h2>
            <p>用过JavaScript的同学们肯定都对prototype如雷贯耳，但是这究竟是个什么东西却让初学者莫衷一是，只知道函数都会有一个prototype属性，可以为其添加函数供实例访问，其它的就不清楚了，最近看了一些 JavaScript高级程序设计，终于揭开了其神秘面纱。

                每个函数都有一个prototype属性，这个属性是指向一个对象的引用，这个对象称为原型对象，原型对象包含函数实例共享的方法和属性，也就是说将函数用作构造函数调用（使用new操作符调用）的时候，新创建的对象会从原型对象上继承属性和方法。</p>
        </li>
        <li>
            <h2>Querystring</h2>
            <p>神奇的deferred模块，语法糖，为解决回调嵌套而生</p>
        </li>
        <li>
            <h2>Seajs</h2>
            <p>SeaJS是一个遵循CommonJS规范的JavaScript模块加载框架，可以实现JavaScript的模块化开发及加载机制。与jQuery等JavaScript框架不同，SeaJS不会扩展封装语言特性，而只是实现JavaScript的模块化及按模块加载。SeaJS的主要目的是令JavaScript开发模块化并可以轻松愉悦进行加载，将前端工程师从繁重的JavaScript文件及对象依赖处理中解放出来，可以专注于代码本身的逻辑。SeaJS可以与jQuery这类框架完美集成。使用SeaJS可以提高JavaScript代码的可读性和清晰度，解决目前JavaScript编程中普遍存在的依赖关系混乱和代码纠缠等问题，方便代码的编写和维护。
            </p>
        </li>
        <li>
            <h2>Trim</h2>
            <p>功能除去字符串开头和末尾的空格或其他字符。函数执行成功时返回删除了string字符串首部和尾部空格的字符串，发生错误时返回空字符串（""）。如果任何参数的值为NULL,Trim() 函数返回NULL。
            </p>
        </li>
        <li>
            <h2>Xss</h2>
            <p>跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意攻击用户的特殊目的。
            </p>
        </li>
        <li>
            <h2>Yslow</h2>
            <p>YSlow是yahoo美国开发的一个页面评分插件，非常的棒，从中我们可以看出我们页面上的很多不足，并且可以知道我们改怎么却改进和优化。
            </p>
        </li>
        <li>
            <h2>Transaction</h2>
            <p>事物处理，隔一段时间去执行一段代码或者执行一个方法
            </p>
        </li>
        <li>
            <h2>icon font</h2>
            <p>在很多网站项目中，我们常常会用到各种透明小图标，然后网站要兼容各个浏览器，也可能会有多个尺寸，甚至还要考虑换肤等需求。那么我们就要将这些小图标输出为多种尺寸、颜色和文件格式，比如png8 alpha透明或者png8 index透明等。
            </p>
        </li>
        <li>
            <h2>EJS</h2>
            <p>EJS在这里专指WEB所使用的模板引擎之一。EJS的优点是将会带给你明确、维护性良好的HTML代码结构。
            </p>
        </li>
    </ul>
<script type="text/javascript">
    console.log(1);
</script>
</body>
</html>